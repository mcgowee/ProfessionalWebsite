import "./chunk-6SECFJDV.js";
import {
  DefaultFocusState,
  MDCMenuFoundation,
  cssClasses
} from "./chunk-H5JUEWNV.js";
import {
  Corner,
  MDCMenuSurfaceFoundation
} from "./chunk-UD4OIQTX.js";
import {
  Graphic,
  classAdderBuilder
} from "./chunk-DA3OYVDR.js";
import "./chunk-J7F4NX7A.js";
import "./chunk-CBIGZ4YA.js";
import {
  classMap,
  dispatch,
  exclude,
  prefixFilter,
  useActions
} from "./chunk-TP3TIDAL.js";
import "./chunk-HDMSCP4O.js";
import "./chunk-TYPVE3OT.js";
import "./chunk-FEV7F3XG.js";
import "./chunk-VLDWWRHJ.js";
import "./chunk-KV6YONZ4.js";
import "./chunk-AJXDWY74.js";
import "./chunk-M43EPEYU.js";
import {
  ponyfill_exports
} from "./chunk-KD76FVNN.js";
import "./chunk-FAAUIAXH.js";
import "./chunk-RWE47MHO.js";
import {
  action,
  add_locations,
  bind_this,
  check_target,
  legacy_api,
  onDestroy,
  onMount,
  prop,
  rest_props,
  set_attributes,
  snippet,
  spread_props,
  validate_prop_bindings,
  wrap_snippet
} from "./chunk-HZ3ZBA3K.js";
import {
  $document,
  FILENAME,
  add_owner_effect,
  append,
  child,
  comment,
  derived,
  equals,
  event,
  first_child,
  get,
  getContext,
  mark_module_end,
  mark_module_start,
  noop,
  pop,
  proxy,
  push,
  reset,
  set,
  setContext,
  state,
  strict_equals,
  template,
  template_effect,
  user_effect
} from "./chunk-C3ERE2HV.js";
import "./chunk-633S47UX.js";
import "./chunk-M4H726CL.js";

// node_modules/@smui/menu-surface/dist/MenuSurface.svelte
mark_module_start();
MenuSurface[FILENAME] = "node_modules/@smui/menu-surface/dist/MenuSurface.svelte";
var root = add_locations(template(`<div><!></div>`), MenuSurface[FILENAME], [[5, 0]]);
function MenuSurface($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, MenuSurface);
  validate_prop_bindings(
    $$props,
    ["open", "anchorElement"],
    [
      "isOpen",
      "setOpen",
      "setAbsolutePosition",
      "setIsHoisted",
      "isFixed",
      "flipCornerHorizontally",
      "getElement"
    ],
    MenuSurface
  );
  let use = prop($$props, "use", 19, () => []), className = prop($$props, "class", 3, ""), style = prop($$props, "style", 3, ""), isStatic = prop($$props, "static", 3, false), anchor = prop($$props, "anchor", 3, true), fixed = prop($$props, "fixed", 3, false), open = prop($$props, "open", 31, () => proxy(isStatic())), managed = prop($$props, "managed", 3, false), fullWidth = prop($$props, "fullWidth", 3, false), quickOpen = prop($$props, "quickOpen", 3, false), anchorElement = prop($$props, "anchorElement", 15), anchorMargin = prop($$props, "anchorMargin", 19, () => ({ top: 0, right: 0, bottom: 0, left: 0 })), maxHeight = prop($$props, "maxHeight", 3, 0), horizontallyCenteredOnViewport = prop($$props, "horizontallyCenteredOnViewport", 3, false), openBottomBias = prop($$props, "openBottomBias", 3, 0), neverRestoreFocus = prop($$props, "neverRestoreFocus", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "use",
      "class",
      "style",
      "static",
      "anchor",
      "fixed",
      "open",
      "managed",
      "fullWidth",
      "quickOpen",
      "anchorElement",
      "anchorCorner",
      "anchorMargin",
      "maxHeight",
      "horizontallyCenteredOnViewport",
      "openBottomBias",
      "neverRestoreFocus",
      "children"
    ],
    "restProps"
  );
  let element;
  let instance = state(void 0);
  let internalClasses = proxy({});
  let internalStyles = proxy({});
  let previousFocus = state(void 0);
  setContext("SMUI:list:role", "menu");
  setContext("SMUI:list:item:role", "menuitem");
  user_effect(() => {
    var _a, _b;
    if (element && anchor() && !((_a = element.parentElement) == null ? void 0 : _a.classList.contains("mdc-menu-surface--anchor"))) {
      (_b = element.parentElement) == null ? void 0 : _b.classList.add("mdc-menu-surface--anchor");
      anchorElement(element.parentElement ?? void 0);
    }
  });
  user_effect(() => {
    if (get(instance) && strict_equals(get(instance).isOpen(), open(), false)) {
      if (open()) {
        get(instance).open();
      } else {
        get(instance).close();
      }
    }
  });
  user_effect(() => {
    if (get(instance)) {
      get(instance).setQuickOpen(quickOpen());
    }
  });
  user_effect(() => {
    if (get(instance)) {
      get(instance).setFixedPosition(fixed());
    }
  });
  user_effect(() => {
    if (get(instance)) {
      get(instance).setMaxHeight(maxHeight());
    }
  });
  user_effect(() => {
    if (get(instance)) {
      get(instance).setIsHorizontallyCenteredOnViewport(horizontallyCenteredOnViewport());
    }
  });
  const iCorner = Corner;
  user_effect(() => {
    if (get(instance) && equals($$props.anchorCorner, null, false)) {
      if (strict_equals(typeof $$props.anchorCorner, "string")) {
        get(instance).setAnchorCorner(iCorner[$$props.anchorCorner]);
      } else {
        get(instance).setAnchorCorner($$props.anchorCorner);
      }
    }
  });
  user_effect(() => {
    if (get(instance)) {
      get(instance).setAnchorMargin(anchorMargin());
    }
  });
  user_effect(() => {
    if (get(instance)) {
      get(instance).setOpenBottomBias(openBottomBias());
    }
  });
  const SMUIMenuSurfaceMount = getContext("SMUI:menu-surface:mount");
  const SMUIMenuSurfaceUnmount = getContext("SMUI:menu-surface:unmount");
  onMount(() => {
    set(instance, proxy(
      new MDCMenuSurfaceFoundation({
        addClass,
        removeClass,
        hasClass,
        hasAnchor: () => !!anchorElement(),
        notifyClose: () => {
          if (!managed()) {
            open(isStatic());
          }
          if (!open()) {
            dispatch(getElement(), "SMUIMenuSurfaceClosed");
          }
        },
        notifyClosing: () => {
          if (!managed()) {
            open(isStatic());
          }
          if (!open()) {
            dispatch(getElement(), "SMUIMenuSurfaceClosing");
          }
        },
        notifyOpen: () => {
          if (!managed()) {
            open(true);
          }
          if (open()) {
            dispatch(getElement(), "SMUIMenuSurfaceOpened");
          }
        },
        notifyOpening: () => {
          if (!open()) {
            dispatch(getElement(), "SMUIMenuSurfaceOpening");
          }
        },
        isElementInContainer: (el) => getElement().contains(el),
        isRtl: () => strict_equals(getComputedStyle(getElement()).getPropertyValue("direction"), "rtl"),
        setTransformOrigin: (origin) => {
          internalStyles["transform-origin"] = origin;
        },
        isFocused: () => strict_equals(document.activeElement, getElement()),
        saveFocus: () => {
          set(previousFocus, proxy(document.activeElement ?? void 0, null, previousFocus));
        },
        restoreFocus: () => {
          if (!neverRestoreFocus() && (!element || getElement().contains(document.activeElement)) && get(previousFocus) && document.contains(get(previousFocus)) && "focus" in get(previousFocus)) {
            get(previousFocus).focus();
          }
        },
        getInnerDimensions: () => {
          return {
            width: getElement().offsetWidth,
            height: getElement().offsetHeight
          };
        },
        getAnchorDimensions: () => anchorElement() ? anchorElement().getBoundingClientRect() : null,
        getWindowDimensions: () => {
          return {
            width: window.innerWidth,
            height: window.innerHeight
          };
        },
        getBodyDimensions: () => {
          return {
            width: document.body.clientWidth,
            height: document.body.clientHeight
          };
        },
        getWindowScroll: () => {
          return { x: window.pageXOffset, y: window.pageYOffset };
        },
        setPosition: (position) => {
          internalStyles.left = "left" in position ? `${position.left}px` : "";
          internalStyles.right = "right" in position ? `${position.right}px` : "";
          internalStyles.top = "top" in position ? `${position.top}px` : "";
          internalStyles.bottom = "bottom" in position ? `${position.bottom}px` : "";
        },
        setMaxHeight: (height) => {
          internalStyles["max-height"] = height;
        }
      }),
      null,
      instance
    ));
    const accessor = {
      get open() {
        return open();
      },
      set open(value) {
        open(value);
      },
      closeProgrammatic
    };
    SMUIMenuSurfaceMount && SMUIMenuSurfaceMount(accessor);
    get(instance).init();
    return () => {
      var _a, _b;
      SMUIMenuSurfaceUnmount && SMUIMenuSurfaceUnmount(accessor);
      const isHoisted = get(instance).isHoistedElement;
      (_a = get(instance)) == null ? void 0 : _a.destroy();
      if (isHoisted) {
        (_b = getElement().parentNode) == null ? void 0 : _b.removeChild(getElement());
      }
    };
  });
  onDestroy(() => {
    var _a;
    if (anchor()) {
      getElement() && ((_a = getElement().parentElement) == null ? void 0 : _a.classList.remove("mdc-menu-surface--anchor"));
    }
  });
  function hasClass(className2) {
    return className2 in internalClasses ? internalClasses[className2] : getElement().classList.contains(className2);
  }
  function addClass(className2) {
    if (!internalClasses[className2]) {
      internalClasses[className2] = true;
    }
  }
  function removeClass(className2) {
    if (!(className2 in internalClasses) || internalClasses[className2]) {
      internalClasses[className2] = false;
    }
  }
  function closeProgrammatic(skipRestoreFocus) {
    var _a;
    (_a = get(instance)) == null ? void 0 : _a.close(skipRestoreFocus);
    open(false);
  }
  function handleBodyClick(event2) {
    if (get(instance) && open() && !managed()) {
      get(instance).handleBodyClick(event2);
    }
  }
  function isOpen() {
    return open();
  }
  function setOpen(value) {
    open(value);
  }
  function setAbsolutePosition(x, y) {
    if (equals(get(instance), null)) {
      throw new Error("Instance is not defined.");
    }
    return get(instance).setAbsolutePosition(x, y);
  }
  function setIsHoisted(isHoisted) {
    if (equals(get(instance), null)) {
      throw new Error("Instance is not defined.");
    }
    return get(instance).setIsHoisted(isHoisted);
  }
  function isFixed() {
    if (equals(get(instance), null)) {
      throw new Error("Instance is not defined.");
    }
    return get(instance).isFixed();
  }
  function flipCornerHorizontally() {
    if (equals(get(instance), null)) {
      throw new Error("Instance is not defined.");
    }
    return get(instance).flipCornerHorizontally();
  }
  function getElement() {
    return element;
  }
  var div = root();
  event("click", $document.body, handleBodyClick, true);
  var event_handler = (e) => {
    var _a;
    if (get(instance) && !managed()) {
      get(instance).handleKeydown(e);
    }
    (_a = $$props.onkeydown) == null ? void 0 : _a.call($$props, e);
  };
  let attributes;
  var node = child(div);
  snippet(node, () => $$props.children ?? noop);
  reset(div);
  bind_this(div, ($$value) => element = $$value, () => element);
  action(div, ($$node, $$action_arg) => {
    var _a;
    return (_a = useActions) == null ? void 0 : _a($$node, $$action_arg);
  }, use);
  template_effect(() => attributes = set_attributes(div, attributes, {
    class: classMap({
      [className()]: true,
      "mdc-menu-surface": true,
      "mdc-menu-surface--fixed": fixed(),
      "mdc-menu-surface--open": isStatic(),
      "smui-menu-surface--static": isStatic(),
      "mdc-menu-surface--fullwidth": fullWidth(),
      ...internalClasses
    }),
    style: Object.entries(internalStyles).map(([name, value]) => `${name}: ${value};`).concat([style()]).join(" "),
    role: "dialog",
    ...restProps,
    onkeydown: event_handler
  }));
  append($$anchor, div);
  return pop({
    get isOpen() {
      return isOpen;
    },
    get setOpen() {
      return setOpen;
    },
    get setAbsolutePosition() {
      return setAbsolutePosition;
    },
    get setIsHoisted() {
      return setIsHoisted;
    },
    get isFixed() {
      return isFixed;
    },
    get flipCornerHorizontally() {
      return flipCornerHorizontally;
    },
    get getElement() {
      return getElement;
    },
    ...legacy_api()
  });
}
mark_module_end(MenuSurface);

// node_modules/@smui/menu-surface/dist/index.js
var dist_default = MenuSurface;

// node_modules/@smui/menu/dist/Menu.svelte
mark_module_start();
Menu[FILENAME] = "node_modules/@smui/menu/dist/Menu.svelte";
function Menu($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Menu);
  validate_prop_bindings(
    $$props,
    ["open", "anchorElement"],
    [
      "isOpen",
      "setOpen",
      "setDefaultFocusState",
      "getSelectedIndex",
      "getMenuSurface",
      "getElement"
    ],
    Menu
  );
  const { closest } = ponyfill_exports;
  let use = prop($$props, "use", 19, () => []), className = prop($$props, "class", 3, ""), open = prop($$props, "open", 15, false), anchorElement = prop($$props, "anchorElement", 15), managed = prop($$props, "managed", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "use",
      "class",
      "open",
      "anchorElement",
      "managed",
      "children"
    ],
    "restProps"
  );
  let element;
  let instance = state(void 0);
  let menuSurfaceAccessor = state(void 0);
  let listAccessor = state(void 0);
  setContext("SMUI:menu-surface:mount", (accessor) => {
    if (!get(menuSurfaceAccessor)) {
      set(menuSurfaceAccessor, proxy(accessor, null, menuSurfaceAccessor));
    }
  });
  const SMUIListMount = getContext("SMUI:list:mount");
  setContext("SMUI:list:mount", (accessor) => {
    if (!get(listAccessor)) {
      set(listAccessor, proxy(accessor, null, listAccessor));
    }
    SMUIListMount && SMUIListMount(accessor);
  });
  const SMUIMenuMount = getContext("SMUI:menu:mount");
  const SMUIMenuUnmount = getContext("SMUI:menu:unmount");
  onMount(() => {
    set(instance, proxy(
      new MDCMenuFoundation({
        addClassToElementAtIndex: (index, className2) => {
          if (equals(get(listAccessor), null)) {
            throw new Error("List accessor is undefined.");
          }
          get(listAccessor).addClassForElementIndex(index, className2);
        },
        removeClassFromElementAtIndex: (index, className2) => {
          if (equals(get(listAccessor), null)) {
            throw new Error("List accessor is undefined.");
          }
          get(listAccessor).removeClassForElementIndex(index, className2);
        },
        addAttributeToElementAtIndex: (index, attr, value) => {
          if (equals(get(listAccessor), null)) {
            throw new Error("List accessor is undefined.");
          }
          get(listAccessor).setAttributeForElementIndex(index, attr, value);
        },
        removeAttributeFromElementAtIndex: (index, attr) => {
          if (equals(get(listAccessor), null)) {
            throw new Error("List accessor is undefined.");
          }
          get(listAccessor).removeAttributeForElementIndex(index, attr);
        },
        getAttributeFromElementAtIndex: (index, attr) => {
          if (equals(get(listAccessor), null)) {
            throw new Error("List accessor is undefined.");
          }
          return get(listAccessor).getAttributeFromElementIndex(index, attr);
        },
        elementContainsClass: (element2, className2) => element2.classList.contains(className2),
        closeSurface: (skipRestoreFocus) => {
          var _a;
          if (!managed()) {
            (_a = get(menuSurfaceAccessor)) == null ? void 0 : _a.closeProgrammatic(skipRestoreFocus);
            dispatch(getElement(), "SMUIMenuClosedProgrammatically");
          }
        },
        getElementIndex: (element2) => {
          if (equals(get(listAccessor), null)) {
            throw new Error("List accessor is undefined.");
          }
          return get(listAccessor).getOrderedList().map((accessor) => accessor.element).indexOf(element2);
        },
        notifySelected: (evtData) => {
          if (equals(get(listAccessor), null)) {
            throw new Error("List accessor is undefined.");
          }
          dispatch(getElement(), "SMUIMenuSelected", {
            index: evtData.index,
            item: get(listAccessor).getOrderedList()[evtData.index].element
          });
        },
        getMenuItemCount: () => {
          if (equals(get(listAccessor), null)) {
            throw new Error("List accessor is undefined.");
          }
          return get(listAccessor).items.length;
        },
        focusItemAtIndex: (index) => {
          if (equals(get(listAccessor), null)) {
            throw new Error("List accessor is undefined.");
          }
          get(listAccessor).focusItemAtIndex(index);
        },
        focusListRoot: () => {
          if (equals(get(listAccessor), null)) {
            throw new Error("List accessor is undefined.");
          }
          if ("focus" in get(listAccessor).element) {
            get(listAccessor).element.focus();
          }
        },
        isSelectableItemAtIndex: (index) => {
          if (equals(get(listAccessor), null)) {
            throw new Error("List accessor is undefined.");
          }
          return !!closest(get(listAccessor).getOrderedList()[index].element, `.${cssClasses.MENU_SELECTION_GROUP}`);
        },
        getSelectedSiblingOfItemAtIndex: (index) => {
          if (equals(get(listAccessor), null)) {
            throw new Error("List accessor is undefined.");
          }
          const orderedList = get(listAccessor).getOrderedList();
          const selectionGroupEl = closest(orderedList[index].element, `.${cssClasses.MENU_SELECTION_GROUP}`);
          const selectedItemEl = selectionGroupEl == null ? void 0 : selectionGroupEl.querySelector(`.${cssClasses.MENU_SELECTED_LIST_ITEM}`);
          return selectedItemEl ? orderedList.map((item) => item.element).indexOf(selectedItemEl) : -1;
        }
      }),
      null,
      instance
    ));
    SMUIMenuMount && SMUIMenuMount(get(instance));
    get(instance).init();
    return () => {
      var _a;
      if (SMUIMenuUnmount && get(instance)) {
        SMUIMenuUnmount(get(instance));
      }
      (_a = get(instance)) == null ? void 0 : _a.destroy();
    };
  });
  function handleKeydown(event2) {
    get(instance) && get(instance).handleKeydown(event2);
  }
  function isOpen() {
    return open();
  }
  function setOpen(value) {
    open(value);
  }
  function setDefaultFocusState(focusState) {
    if (equals(get(instance), null)) {
      throw new Error("Instance is undefined.");
    }
    get(instance).setDefaultFocusState(focusState);
  }
  function getSelectedIndex() {
    if (equals(get(instance), null)) {
      throw new Error("Instance is undefined.");
    }
    return get(instance).getSelectedIndex();
  }
  function getMenuSurface() {
    return element;
  }
  function getElement() {
    return element.getElement();
  }
  var class_1 = derived(() => classMap({ [className()]: true, "mdc-menu": true }));
  {
    add_owner_effect(open, dist_default);
    add_owner_effect(anchorElement, dist_default);
    bind_this(
      dist_default($$anchor, spread_props(
        {
          get use() {
            return use();
          },
          get class() {
            return get(class_1);
          },
          get managed() {
            return managed();
          }
        },
        () => restProps,
        {
          onkeydown: (e) => {
            var _a;
            handleKeydown(e);
            (_a = $$props.onkeydown) == null ? void 0 : _a.call($$props, e);
          },
          onSMUIMenuSurfaceOpened: (e) => {
            var _a;
            if (get(instance)) {
              get(instance).handleMenuSurfaceOpened();
            }
            (_a = $$props.onSMUIMenuSurfaceOpened) == null ? void 0 : _a.call($$props, e);
          },
          onSMUIListAction: (e) => {
            var _a;
            if (get(instance) && get(listAccessor)) {
              get(instance).handleItemAction(get(listAccessor).getOrderedList()[e.detail.index].element);
            }
            (_a = $$props.onSMUIListAction) == null ? void 0 : _a.call($$props, e);
          },
          get open() {
            return open();
          },
          set open($$value) {
            open($$value);
          },
          get anchorElement() {
            return anchorElement();
          },
          set anchorElement($$value) {
            anchorElement($$value);
          },
          children: wrap_snippet(Menu, ($$anchor2, $$slotProps) => {
            var fragment_1 = comment();
            var node = first_child(fragment_1);
            snippet(node, () => $$props.children ?? noop);
            append($$anchor2, fragment_1);
          }),
          $$slots: { default: true }
        }
      )),
      ($$value) => element = $$value,
      () => element
    );
  }
  return pop({
    get isOpen() {
      return isOpen;
    },
    get setOpen() {
      return setOpen;
    },
    get setDefaultFocusState() {
      return setDefaultFocusState;
    },
    get getSelectedIndex() {
      return getSelectedIndex;
    },
    get getMenuSurface() {
      return getMenuSurface;
    },
    get getElement() {
      return getElement;
    },
    ...legacy_api()
  });
}
mark_module_end(Menu);

// node_modules/@smui/menu/dist/SelectionGroup.svelte
mark_module_start();
SelectionGroup[FILENAME] = "node_modules/@smui/menu/dist/SelectionGroup.svelte";
var root2 = add_locations(template(`<li><ul><!></ul></li>`), SelectionGroup[FILENAME], [[3, 0, [[4, 2]]]]);
function SelectionGroup($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, SelectionGroup);
  validate_prop_bindings($$props, [], ["getElement"], SelectionGroup);
  let use = prop($$props, "use", 19, () => []), list$use = prop($$props, "list$use", 19, () => []), list$class = prop($$props, "list$class", 3, ""), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "use",
      "list$use",
      "list$class",
      "children"
    ],
    "restProps"
  );
  let element;
  setContext("SMUI:list:graphic:menu-selection-group", true);
  function getElement() {
    return element;
  }
  var li = root2();
  const spread_with_call = derived(() => exclude(restProps, ["list$"]));
  let attributes;
  var ul = child(li);
  const spread_with_call_1 = derived(() => prefixFilter(restProps, "list$"));
  let attributes_1;
  var node = child(ul);
  snippet(node, () => $$props.children ?? noop);
  reset(ul);
  action(ul, ($$node, $$action_arg) => {
    var _a;
    return (_a = useActions) == null ? void 0 : _a($$node, $$action_arg);
  }, list$use);
  reset(li);
  bind_this(li, ($$value) => element = $$value, () => element);
  action(li, ($$node, $$action_arg) => {
    var _a;
    return (_a = useActions) == null ? void 0 : _a($$node, $$action_arg);
  }, use);
  template_effect(() => {
    attributes = set_attributes(li, attributes, { ...get(spread_with_call) });
    attributes_1 = set_attributes(ul, attributes_1, {
      class: classMap({
        [list$class()]: true,
        "mdc-menu__selection-group": true
      }),
      ...get(spread_with_call_1)
    });
  });
  append($$anchor, li);
  return pop({
    get getElement() {
      return getElement;
    },
    ...legacy_api()
  });
}
mark_module_end(SelectionGroup);

// node_modules/@smui/menu/dist/SelectionGroupIcon.js
var SelectionGroupIcon_default = classAdderBuilder({
  class: "mdc-menu__selection-group-icon",
  component: Graphic
});

// node_modules/@smui/menu/dist/index.js
var dist_default2 = Menu;
export {
  DefaultFocusState,
  SelectionGroup,
  SelectionGroupIcon_default as SelectionGroupIcon,
  dist_default2 as default
};
//# sourceMappingURL=@smui_menu.js.map
