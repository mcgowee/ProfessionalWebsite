import {
  MDCListFoundation
} from "./chunk-CBIGZ4YA.js";
import {
  SmuiElement,
  classMap,
  dispatch,
  dist_default,
  useActions
} from "./chunk-TP3TIDAL.js";
import {
  ponyfill_exports
} from "./chunk-KD76FVNN.js";
import {
  action,
  add_locations,
  bind_this,
  check_target,
  component,
  if_block,
  legacy_api,
  onDestroy,
  onMount,
  prop,
  rest_props,
  set_attributes,
  snippet,
  spread_props,
  validate_prop_bindings,
  wrap_snippet
} from "./chunk-HZ3ZBA3K.js";
import {
  FILENAME,
  append,
  child,
  comment,
  derived,
  equals,
  first_child,
  get,
  getContext,
  mark_module_end,
  mark_module_start,
  noop,
  pop,
  proxy,
  push,
  reset,
  set,
  setContext,
  sibling,
  state,
  strict_equals,
  template,
  template_effect,
  user_effect
} from "./chunk-C3ERE2HV.js";

// node_modules/@smui/list/dist/List.svelte
mark_module_start();
List[FILENAME] = "node_modules/@smui/list/dist/List.svelte";
function List($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, List);
  validate_prop_bindings(
    $$props,
    ["selectedIndex"],
    [
      "layout",
      "setEnabled",
      "getTypeaheadInProgress",
      "getSelectedIndex",
      "getFocusedItemIndex",
      "focusItemAtIndex",
      "getElement"
    ],
    List
  );
  const { closest, matches } = ponyfill_exports;
  let nav = getContext("SMUI:list:nav");
  let use = prop($$props, "use", 19, () => []), className = prop($$props, "class", 3, ""), nonInteractive = prop($$props, "nonInteractive", 3, false), dense = prop($$props, "dense", 3, false), textualList = prop($$props, "textualList", 3, false), avatarList = prop($$props, "avatarList", 3, false), iconList = prop($$props, "iconList", 3, false), imageList = prop($$props, "imageList", 3, false), thumbnailList = prop($$props, "thumbnailList", 3, false), videoList = prop($$props, "videoList", 3, false), twoLine = prop($$props, "twoLine", 3, false), threeLine = prop($$props, "threeLine", 3, false), vertical = prop($$props, "vertical", 3, true), wrapFocus = prop($$props, "wrapFocus", 19, () => getContext("SMUI:list:wrapFocus") ?? false), singleSelection = prop($$props, "singleSelection", 3, false), disabledItemsFocusable = prop($$props, "disabledItemsFocusable", 3, false), selectedIndex = prop($$props, "selectedIndex", 31, () => -1), radioList = prop($$props, "radioList", 3, false), checkList = prop($$props, "checkList", 3, false), hasTypeahead = prop($$props, "hasTypeahead", 3, false), MyComponent = prop($$props, "component", 3, SmuiElement), tag = prop($$props, "tag", 3, nav ? "nav" : "ul"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "use",
      "class",
      "nonInteractive",
      "dense",
      "textualList",
      "avatarList",
      "iconList",
      "imageList",
      "thumbnailList",
      "videoList",
      "twoLine",
      "threeLine",
      "vertical",
      "wrapFocus",
      "singleSelection",
      "disabledItemsFocusable",
      "selectedIndex",
      "radioList",
      "checkList",
      "hasTypeahead",
      "component",
      "tag",
      "children"
    ],
    "restProps"
  );
  let element;
  let instance = state(void 0);
  let items = [];
  let role = getContext("SMUI:list:role");
  const itemAccessorMap = /* @__PURE__ */ new WeakMap();
  let selectionDialog = getContext("SMUI:dialog:selection");
  let addLayoutListener = getContext("SMUI:addLayoutListener");
  let removeLayoutListener;
  setContext("SMUI:list:nonInteractive", nonInteractive());
  setContext("SMUI:separator:context", "list");
  if (!role) {
    if (singleSelection()) {
      role = "listbox";
      setContext("SMUI:list:item:role", "option");
    } else if (radioList()) {
      role = "radiogroup";
      setContext("SMUI:list:item:role", "radio");
    } else if (checkList()) {
      role = "group";
      setContext("SMUI:list:item:role", "checkbox");
    } else {
      role = "list";
      setContext("SMUI:list:item:role", void 0);
    }
  }
  user_effect(() => {
    if (get(instance)) {
      get(instance).setVerticalOrientation(vertical());
    }
  });
  user_effect(() => {
    if (get(instance)) {
      get(instance).setWrapFocus(wrapFocus());
    }
  });
  user_effect(() => {
    if (get(instance)) {
      get(instance).setHasTypeahead(hasTypeahead());
    }
  });
  user_effect(() => {
    if (get(instance)) {
      get(instance).setSingleSelection(singleSelection());
    }
  });
  user_effect(() => {
    if (get(instance)) {
      get(instance).setDisabledItemsFocusable(disabledItemsFocusable());
    }
  });
  user_effect(() => {
    if (get(instance) && singleSelection() && strict_equals(getSelectedIndex(), selectedIndex(), false)) {
      get(instance).setSelectedIndex(selectedIndex());
    }
  });
  if (addLayoutListener) {
    removeLayoutListener = addLayoutListener(layout);
  }
  setContext("SMUI:list:item:mount", (accessor) => {
    items.push(accessor);
    itemAccessorMap.set(accessor.element, accessor);
    if (singleSelection() && accessor.selected) {
      selectedIndex(getListItemIndex(accessor.element));
    }
  });
  setContext("SMUI:list:item:unmount", (accessor) => {
    const idx = (accessor && items.findIndex((a) => strict_equals(a, accessor))) ?? -1;
    if (strict_equals(idx, -1, false)) {
      items.splice(idx, 1);
      itemAccessorMap.delete(accessor.element);
    }
  });
  const SMUIListMount = getContext("SMUI:list:mount");
  const SMUIListUnmount = getContext("SMUI:list:unmount");
  onMount(() => {
    set(instance, proxy(
      new MDCListFoundation({
        addClassForElementIndex,
        focusItemAtIndex,
        getAttributeForElementIndex: (index, name) => {
          var _a;
          return ((_a = getOrderedList()[index]) == null ? void 0 : _a.getAttr(name)) ?? null;
        },
        getFocusedElementIndex: () => document.activeElement ? getOrderedList().map((accessor2) => accessor2.element).indexOf(document.activeElement) : -1,
        getListItemCount: () => items.length,
        getPrimaryTextAtIndex,
        hasCheckboxAtIndex: (index) => {
          var _a;
          return ((_a = getOrderedList()[index]) == null ? void 0 : _a.hasCheckbox) ?? false;
        },
        hasRadioAtIndex: (index) => {
          var _a;
          return ((_a = getOrderedList()[index]) == null ? void 0 : _a.hasRadio) ?? false;
        },
        isCheckboxCheckedAtIndex: (index) => {
          const listItem = getOrderedList()[index];
          return ((listItem == null ? void 0 : listItem.hasCheckbox) && listItem.checked) ?? false;
        },
        isFocusInsideList: () => equals(element, null, false) && strict_equals(getElement(), document.activeElement, false) && getElement().contains(document.activeElement),
        isRootFocused: () => equals(element, null, false) && strict_equals(document.activeElement, getElement()),
        listItemAtIndexHasClass,
        notifyAction: (index) => {
          selectedIndex(index);
          if (equals(element, null, false)) {
            dispatch(getElement(), "SMUIListAction", { index });
          }
        },
        notifySelectionChange: (changedIndices) => {
          if (equals(element, null, false)) {
            dispatch(getElement(), "SMUIListSelectionChange", { changedIndices });
          }
        },
        removeClassForElementIndex,
        setAttributeForElementIndex,
        setCheckedCheckboxOrRadioAtIndex: (index, isChecked) => {
          getOrderedList()[index].checked = isChecked;
        },
        setTabIndexForListItemChildren: (listItemIndex, tabIndexValue) => {
          const listItem = getOrderedList()[listItemIndex];
          const selector = "button:not(:disabled), a";
          Array.prototype.forEach.call(listItem.element.querySelectorAll(selector), (el) => {
            el.setAttribute("tabindex", tabIndexValue);
          });
        }
      }),
      null,
      instance
    ));
    const accessor = {
      get element() {
        return getElement();
      },
      get items() {
        return items;
      },
      get typeaheadInProgress() {
        if (!get(instance)) {
          throw new Error("Instance is undefined.");
        }
        return get(instance).isTypeaheadInProgress();
      },
      typeaheadMatchItem(nextChar, startingIndex) {
        if (!get(instance)) {
          throw new Error("Instance is undefined.");
        }
        return get(instance).typeaheadMatchItem(
          nextChar,
          startingIndex,
          /** skipFocus */
          true
        );
      },
      getOrderedList,
      focusItemAtIndex,
      addClassForElementIndex,
      removeClassForElementIndex,
      setAttributeForElementIndex,
      removeAttributeForElementIndex,
      getAttributeFromElementIndex,
      getPrimaryTextAtIndex
    };
    SMUIListMount && SMUIListMount(accessor);
    get(instance).init();
    get(instance).layout();
    return () => {
      var _a;
      SMUIListUnmount && SMUIListUnmount(accessor);
      (_a = get(instance)) == null ? void 0 : _a.destroy();
    };
  });
  onDestroy(() => {
    if (removeLayoutListener) {
      removeLayoutListener();
    }
  });
  function handleKeydown(event) {
    if (get(instance) && event.target) {
      get(instance).handleKeydown(event, event.target.classList.contains("mdc-deprecated-list-item"), getListItemIndex(event.target));
    }
  }
  function handleFocusin(event) {
    if (get(instance) && event.target) {
      get(instance).handleFocusIn(getListItemIndex(event.target));
    }
  }
  function handleFocusout(event) {
    if (get(instance) && event.target) {
      get(instance).handleFocusOut(getListItemIndex(event.target));
    }
  }
  function handleClick(event) {
    if (get(instance) && event.target) {
      get(instance).handleClick(getListItemIndex(event.target), !matches(event.target, 'input[type="checkbox"], input[type="radio"]'), event);
    }
  }
  function handleAction(event) {
    if (radioList() || checkList()) {
      const index = getListItemIndex(event.target);
      if (strict_equals(index, -1, false)) {
        const item = getOrderedList()[index];
        if (item && (radioList() && !item.checked || checkList())) {
          if (!matches(event.detail.target, 'input[type="checkbox"], input[type="radio"]')) {
            item.checked = !item.checked;
          }
          item.activateRipple();
          window.requestAnimationFrame(() => {
            item.deactivateRipple();
          });
        }
      }
    }
  }
  function getOrderedList() {
    if (equals(element, null)) {
      return [];
    }
    return [...getElement().children].map((element2) => itemAccessorMap.get(element2)).filter((accessor) => accessor && accessor._smui_list_item_accessor);
  }
  function listItemAtIndexHasClass(index, className2) {
    const accessor = getOrderedList()[index];
    return (accessor && accessor.hasClass(className2)) ?? false;
  }
  function addClassForElementIndex(index, className2) {
    const accessor = getOrderedList()[index];
    accessor && accessor.addClass(className2);
  }
  function removeClassForElementIndex(index, className2) {
    const accessor = getOrderedList()[index];
    accessor && accessor.removeClass(className2);
  }
  function setAttributeForElementIndex(index, name, value) {
    const accessor = getOrderedList()[index];
    accessor && accessor.addAttr(name, value);
  }
  function removeAttributeForElementIndex(index, name) {
    const accessor = getOrderedList()[index];
    accessor && accessor.removeAttr(name);
  }
  function getAttributeFromElementIndex(index, name) {
    const accessor = getOrderedList()[index];
    if (accessor) {
      return accessor.getAttr(name);
    } else {
      return null;
    }
  }
  function getPrimaryTextAtIndex(index) {
    const accessor = getOrderedList()[index];
    return (accessor && accessor.getPrimaryText()) ?? "";
  }
  function getListItemIndex(element2) {
    const nearestParent = closest(element2, ".mdc-deprecated-list-item, .mdc-deprecated-list");
    if (nearestParent && matches(nearestParent, ".mdc-deprecated-list-item")) {
      return getOrderedList().map((item) => item == null ? void 0 : item.element).indexOf(nearestParent);
    }
    return -1;
  }
  function layout() {
    if (!get(instance)) {
      throw new Error("Instance is undefined.");
    }
    return get(instance).layout();
  }
  function setEnabled(itemIndex, isEnabled) {
    if (!get(instance)) {
      throw new Error("Instance is undefined.");
    }
    return get(instance).setEnabled(itemIndex, isEnabled);
  }
  function getTypeaheadInProgress() {
    if (!get(instance)) {
      throw new Error("Instance is undefined.");
    }
    return get(instance).isTypeaheadInProgress();
  }
  function getSelectedIndex() {
    if (!get(instance)) {
      throw new Error("Instance is undefined.");
    }
    return get(instance).getSelectedIndex();
  }
  function getFocusedItemIndex() {
    if (!get(instance)) {
      throw new Error("Instance is undefined.");
    }
    return get(instance).getFocusedItemIndex();
  }
  function focusItemAtIndex(index) {
    const accessor = getOrderedList()[index];
    accessor && "focus" in accessor.element && accessor.element.focus();
  }
  function getElement() {
    return element.getElement();
  }
  var fragment = comment();
  var node = first_child(fragment);
  var class_1 = derived(() => classMap({
    [className()]: true,
    "mdc-deprecated-list": true,
    "mdc-deprecated-list--non-interactive": nonInteractive(),
    "mdc-deprecated-list--dense": dense(),
    "mdc-deprecated-list--textual-list": textualList(),
    "mdc-deprecated-list--avatar-list": avatarList() || selectionDialog,
    "mdc-deprecated-list--icon-list": iconList(),
    "mdc-deprecated-list--image-list": imageList(),
    "mdc-deprecated-list--thumbnail-list": thumbnailList(),
    "mdc-deprecated-list--video-list": videoList(),
    "mdc-deprecated-list--two-line": twoLine(),
    "smui-list--three-line": threeLine() && !twoLine()
  }));
  component(node, MyComponent, ($$anchor2, $$component) => {
    bind_this(
      $$component($$anchor2, spread_props(
        {
          get tag() {
            return tag();
          },
          get use() {
            return use();
          },
          get class() {
            return get(class_1);
          },
          role
        },
        () => restProps,
        {
          onkeydown: (e) => {
            var _a;
            handleKeydown(e);
            (_a = $$props.onkeydown) == null ? void 0 : _a.call($$props, e);
          },
          onfocusin: (e) => {
            var _a;
            handleFocusin(e);
            (_a = $$props.onfocusin) == null ? void 0 : _a.call($$props, e);
          },
          onfocusout: (e) => {
            var _a;
            handleFocusout(e);
            (_a = $$props.onfocusout) == null ? void 0 : _a.call($$props, e);
          },
          onclick: (e) => {
            var _a;
            handleClick(e);
            (_a = $$props.onclick) == null ? void 0 : _a.call($$props, e);
          },
          onSMUIAction: (e) => {
            var _a;
            handleAction(e);
            (_a = $$props.onSMUIAction) == null ? void 0 : _a.call($$props, e);
          },
          children: wrap_snippet(List, ($$anchor3, $$slotProps) => {
            var fragment_1 = comment();
            var node_1 = first_child(fragment_1);
            snippet(node_1, () => $$props.children ?? noop);
            append($$anchor3, fragment_1);
          }),
          $$slots: { default: true }
        }
      )),
      ($$value) => element = $$value,
      () => element
    );
  });
  append($$anchor, fragment);
  return pop({
    get layout() {
      return layout;
    },
    get setEnabled() {
      return setEnabled;
    },
    get getTypeaheadInProgress() {
      return getTypeaheadInProgress;
    },
    get getSelectedIndex() {
      return getSelectedIndex;
    },
    get getFocusedItemIndex() {
      return getFocusedItemIndex;
    },
    get focusItemAtIndex() {
      return focusItemAtIndex;
    },
    get getElement() {
      return getElement;
    },
    ...legacy_api()
  });
}
mark_module_end(List);

// node_modules/@smui/list/dist/Item.svelte
mark_module_start();
Item[FILENAME] = "node_modules/@smui/list/dist/Item.svelte";
var counter = 0;
var root_2 = add_locations(template(`<span class="mdc-deprecated-list-item__ripple"></span>`), Item[FILENAME], [[63, 15]]);
var root_1 = add_locations(template(`<!><!>`, 1), Item[FILENAME], []);
function Item($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Item);
  validate_prop_bindings($$props, ["activated", "selected", "tabindex"], ["action", "getPrimaryText", "getElement"], Item);
  let uninitializedValue = () => {
  };
  function isUninitializedValue(value) {
    return strict_equals(value, uninitializedValue);
  }
  let nav = getContext("SMUI:list:item:nav");
  let use = prop($$props, "use", 19, () => []), className = prop($$props, "class", 3, ""), style = prop($$props, "style", 3, ""), nonInteractive = prop($$props, "nonInteractive", 19, () => getContext("SMUI:list:nonInteractive") ?? false), ripple = prop($$props, "ripple", 19, () => !nonInteractive()), wrapper = prop($$props, "wrapper", 3, false), activated = prop($$props, "activated", 15, false), role = prop($$props, "role", 19, () => wrapper() ? "presentation" : getContext("SMUI:list:item:role")), selected = prop($$props, "selected", 15, false), disabled = prop($$props, "disabled", 3, false), skipRestoreFocus = prop($$props, "skipRestoreFocus", 3, false), tabindexProp = prop($$props, "tabindex", 15, uninitializedValue), inputId = prop($$props, "inputId", 19, () => "SMUI-form-field-list-" + counter++), MyComponent = prop($$props, "component", 3, SmuiElement), tag = prop($$props, "tag", 19, () => nav ? $$props.href ? "a" : "span" : "li"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "use",
      "class",
      "style",
      "color",
      "nonInteractive",
      "ripple",
      "wrapper",
      "activated",
      "role",
      "selected",
      "disabled",
      "skipRestoreFocus",
      "tabindex",
      "inputId",
      "href",
      "component",
      "tag",
      "children"
    ],
    "restProps"
  );
  setContext("SMUI:list:nonInteractive", void 0);
  setContext("SMUI:list:item:role", void 0);
  let element;
  let internalClasses = proxy({});
  let internalStyles = proxy({});
  let internalAttrs = proxy({});
  let input = state(void 0);
  let addTabindexIfNoItemsSelectedRaf = state(void 0);
  const tabindex = derived(() => isUninitializedValue(tabindexProp()) ? !nonInteractive() && !disabled() && (selected() || get(input) && get(input).checked) ? 0 : -1 : tabindexProp());
  setContext("SMUI:generic:input:props", { id: inputId() });
  setContext("SMUI:separator:context", void 0);
  setContext("SMUI:generic:input:mount", (accessor) => {
    if ("_smui_checkbox_accessor" in accessor || "_smui_radio_accessor" in accessor) {
      set(input, proxy(accessor, null, input));
    }
  });
  setContext("SMUI:generic:input:unmount", () => {
    set(input, void 0);
  });
  const SMUIListItemMount = getContext("SMUI:list:item:mount");
  const SMUIListItemUnmount = getContext("SMUI:list:item:unmount");
  onMount(() => {
    if (!selected() && !nonInteractive()) {
      let first = true;
      let el = element.getElement();
      while (el.previousElementSibling) {
        el = el.previousElementSibling;
        if (strict_equals(el.nodeType, 1) && el.classList.contains("mdc-deprecated-list-item") && !el.classList.contains("mdc-deprecated-list-item--disabled")) {
          first = false;
          break;
        }
      }
      if (first) {
        set(addTabindexIfNoItemsSelectedRaf, proxy(window.requestAnimationFrame(() => addTabindexIfNoItemsSelected(el)), null, addTabindexIfNoItemsSelectedRaf));
      }
    }
    const accessor = {
      _smui_list_item_accessor: true,
      get element() {
        return getElement();
      },
      get selected() {
        return selected();
      },
      set selected(value) {
        selected(value);
      },
      hasClass,
      addClass,
      removeClass,
      getAttr,
      addAttr,
      removeAttr,
      getPrimaryText,
      get checked() {
        return (get(input) && get(input).checked) ?? false;
      },
      set checked(value) {
        if (get(input)) {
          get(input).checked = !!value;
        }
      },
      get hasCheckbox() {
        return !!(get(input) && "_smui_checkbox_accessor" in get(input));
      },
      get hasRadio() {
        return !!(get(input) && "_smui_radio_accessor" in get(input));
      },
      activateRipple() {
        if (get(input)) {
          get(input).activateRipple();
        }
      },
      deactivateRipple() {
        if (get(input)) {
          get(input).deactivateRipple();
        }
      },
      getValue() {
        return $$props.value;
      },
      // For autocomplete
      action: action2,
      get tabindex() {
        return get(tabindex);
      },
      set tabindex(value) {
        tabindexProp(value);
      },
      get disabled() {
        return disabled();
      },
      get activated() {
        return activated();
      },
      set activated(value) {
        activated(value);
      }
    };
    SMUIListItemMount && SMUIListItemMount(accessor);
    return () => {
      SMUIListItemUnmount && SMUIListItemUnmount(accessor);
    };
  });
  onDestroy(() => {
    if (get(addTabindexIfNoItemsSelectedRaf)) {
      window.cancelAnimationFrame(get(addTabindexIfNoItemsSelectedRaf));
    }
  });
  function hasClass(className2) {
    return className2 in internalClasses ? internalClasses[className2] : getElement().classList.contains(className2);
  }
  function addClass(className2) {
    if (!internalClasses[className2]) {
      internalClasses[className2] = true;
    }
  }
  function removeClass(className2) {
    if (!(className2 in internalClasses) || internalClasses[className2]) {
      internalClasses[className2] = false;
    }
  }
  function addStyle(name, value) {
    if (equals(internalStyles[name], value, false)) {
      if (strict_equals(value, "") || equals(value, null)) {
        delete internalStyles[name];
      } else {
        internalStyles[name] = value;
      }
    }
  }
  function getAttr(name) {
    return name in internalAttrs ? internalAttrs[name] ?? null : getElement().getAttribute(name);
  }
  function addAttr(name, value) {
    if (strict_equals(internalAttrs[name], value, false)) {
      internalAttrs[name] = value;
    }
  }
  function removeAttr(name) {
    if (!(name in internalAttrs) || equals(internalAttrs[name], null, false)) {
      internalAttrs[name] = void 0;
    }
  }
  function addTabindexIfNoItemsSelected(el) {
    let noneSelected = true;
    while (el.nextElementSibling) {
      el = el.nextElementSibling;
      if (strict_equals(el.nodeType, 1) && el.classList.contains("mdc-deprecated-list-item")) {
        const tabindexAttr = el.attributes.getNamedItem("tabindex");
        if (tabindexAttr && strict_equals(tabindexAttr.value, "0")) {
          noneSelected = false;
          break;
        }
      }
    }
    if (noneSelected) {
      tabindexProp(0);
    }
  }
  function handleKeydown(e) {
    const isEnter = strict_equals(e.key, "Enter");
    const isSpace = strict_equals(e.key, "Space");
    if (isEnter || isSpace) {
      action2(e);
    }
  }
  function action2(e) {
    if (!disabled()) {
      dispatch(getElement(), "SMUIAction", e);
    }
  }
  function getPrimaryText() {
    const element2 = getElement();
    const primaryText = element2.querySelector(".mdc-deprecated-list-item__primary-text");
    if (primaryText) {
      return primaryText.textContent ?? "";
    }
    const text = element2.querySelector(".mdc-deprecated-list-item__text");
    if (text) {
      return text.textContent ?? "";
    }
    return element2.textContent ?? "";
  }
  function getElement() {
    return element.getElement();
  }
  var fragment = comment();
  var node = first_child(fragment);
  var use_1 = derived(() => [
    ...nonInteractive() ? [] : [
      [
        dist_default,
        {
          ripple: !get(input),
          unbounded: false,
          color: (activated() || selected()) && equals($$props.color, null) ? "primary" : $$props.color,
          disabled: disabled(),
          addClass,
          removeClass,
          addStyle
        }
      ]
    ],
    ...use()
  ]);
  var class_1 = derived(() => classMap({
    [className()]: true,
    "mdc-deprecated-list-item": !wrapper(),
    "mdc-deprecated-list-item__wrapper": wrapper(),
    "mdc-deprecated-list-item--activated": activated(),
    "mdc-deprecated-list-item--selected": selected(),
    "mdc-deprecated-list-item--disabled": disabled(),
    "mdc-menu-item--selected": !nav && strict_equals(role(), "menuitem") && selected(),
    "smui-menu-item--non-interactive": nonInteractive(),
    ...internalClasses
  }));
  var style_1 = derived(() => Object.entries(internalStyles).map(([name, value]) => `${name}: ${value};`).concat([style()]).join(" "));
  var data_menu_item_skip_restore_focus = derived(() => skipRestoreFocus() || void 0);
  component(node, MyComponent, ($$anchor2, $$component) => {
    bind_this(
      $$component($$anchor2, spread_props(
        {
          get tag() {
            return tag();
          },
          get use() {
            return get(use_1);
          },
          get class() {
            return get(class_1);
          },
          get style() {
            return get(style_1);
          }
        },
        () => nav && activated() ? { "aria-current": "page" } : {},
        () => !nav || wrapper() ? { role: role() } : {},
        () => !nav && strict_equals(role(), "option") ? {
          "aria-selected": selected() ? "true" : "false"
        } : {},
        () => !nav && (strict_equals(role(), "radio") || strict_equals(role(), "checkbox")) ? {
          "aria-checked": get(input) && get(input).checked ? "true" : "false"
        } : {},
        () => !nav ? {
          "aria-disabled": disabled() ? "true" : "false"
        } : {},
        {
          get "data-menu-item-skip-restore-focus"() {
            return get(data_menu_item_skip_restore_focus);
          },
          get tabindex() {
            return get(tabindex);
          },
          get href() {
            return $$props.href;
          }
        },
        () => internalAttrs,
        () => restProps,
        {
          onclick: (e) => {
            var _a;
            action2(e);
            (_a = $$props.onclick) == null ? void 0 : _a.call($$props, e);
          },
          onkeydown: (e) => {
            var _a;
            handleKeydown(e);
            (_a = $$props.onkeydown) == null ? void 0 : _a.call($$props, e);
          },
          children: wrap_snippet(Item, ($$anchor3, $$slotProps) => {
            var fragment_1 = root_1();
            var node_1 = first_child(fragment_1);
            {
              var consequent = ($$anchor4) => {
                var span = root_2();
                append($$anchor4, span);
              };
              if_block(node_1, ($$render) => {
                if (ripple()) $$render(consequent);
              });
            }
            var node_2 = sibling(node_1);
            snippet(node_2, () => $$props.children ?? noop);
            append($$anchor3, fragment_1);
          }),
          $$slots: { default: true }
        }
      )),
      ($$value) => element = $$value,
      () => element
    );
  });
  append($$anchor, fragment);
  return pop({
    get action() {
      return action2;
    },
    get getPrimaryText() {
      return getPrimaryText;
    },
    get getElement() {
      return getElement;
    },
    ...legacy_api()
  });
}
mark_module_end(Item);

// node_modules/@smui/common/dist/classadder/ClassAdder.svelte
mark_module_start();
ClassAdder[FILENAME] = "node_modules/@smui/common/dist/classadder/ClassAdder.svelte";
function ClassAdder($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, ClassAdder);
  validate_prop_bindings($$props, [], ["getElement"], ClassAdder);
  let use = prop($$props, "use", 19, () => []), className = prop($$props, "class", 3, ""), _internals = prop($$props, "_internals", 19, () => ({
    component: SmuiElement,
    tag: "div",
    class: "",
    classMap: {},
    contexts: {},
    props: {}
  })), MyComponent = prop($$props, "component", 19, () => _internals().component), tag = prop($$props, "tag", 19, () => _internals().tag), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "use",
      "class",
      "_internals",
      "component",
      "tag",
      "children"
    ],
    "restProps"
  );
  let element;
  const smuiClass = proxy(_internals().class);
  const smuiClassMap = proxy({});
  const smuiClassUnsubscribes = [];
  const contexts = proxy(_internals().contexts);
  const props = proxy(_internals().props);
  Object.entries(_internals().classMap).forEach(([name, context]) => {
    const store = getContext(context);
    if (store && "subscribe" in store) {
      smuiClassUnsubscribes.push(store.subscribe((value) => {
        smuiClassMap[name] = value;
      }));
    }
  });
  for (let context in contexts) {
    if (contexts.hasOwnProperty(context)) {
      setContext(context, contexts[context]);
    }
  }
  onDestroy(() => {
    for (const unsubscribe of smuiClassUnsubscribes) {
      unsubscribe();
    }
  });
  function getElement() {
    return element.getElement();
  }
  var fragment = comment();
  var node = first_child(fragment);
  var class_1 = derived(() => classMap({
    [className()]: true,
    [smuiClass]: true,
    ...smuiClassMap
  }));
  component(node, MyComponent, ($$anchor2, $$component) => {
    bind_this(
      $$component($$anchor2, spread_props(
        {
          get tag() {
            return tag();
          },
          get use() {
            return use();
          },
          get class() {
            return get(class_1);
          }
        },
        () => props,
        () => restProps,
        {
          children: wrap_snippet(ClassAdder, ($$anchor3, $$slotProps) => {
            var fragment_1 = comment();
            var node_1 = first_child(fragment_1);
            snippet(node_1, () => $$props.children ?? noop);
            append($$anchor3, fragment_1);
          }),
          $$slots: { default: true }
        }
      )),
      ($$value) => element = $$value,
      () => element
    );
  });
  append($$anchor, fragment);
  return pop({
    get getElement() {
      return getElement;
    },
    ...legacy_api()
  });
}
mark_module_end(ClassAdder);

// node_modules/@smui/common/dist/classadder/classAdderBuilder.js
function classAdderBuilder(internals) {
  return function(anchor, props) {
    return ClassAdder(anchor, Object.assign(Object.assign({}, props), { _internals: Object.assign({ component: SmuiElement, tag: "div", class: "", classMap: {}, contexts: {}, props: {} }, internals) }));
  };
}

// node_modules/@smui/list/dist/Text.js
var Text_default = classAdderBuilder({
  class: "mdc-deprecated-list-item__text",
  tag: "span"
});

// node_modules/@smui/list/dist/PrimaryText.js
var PrimaryText_default = classAdderBuilder({
  class: "mdc-deprecated-list-item__primary-text",
  tag: "span"
});

// node_modules/@smui/list/dist/SecondaryText.js
var SecondaryText_default = classAdderBuilder({
  class: "mdc-deprecated-list-item__secondary-text",
  tag: "span"
});

// node_modules/@smui/list/dist/Graphic.svelte
mark_module_start();
Graphic[FILENAME] = "node_modules/@smui/list/dist/Graphic.svelte";
var root = add_locations(template(`<span><!></span>`), Graphic[FILENAME], [[3, 0]]);
function Graphic($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Graphic);
  validate_prop_bindings($$props, [], ["getElement"], Graphic);
  let use = prop($$props, "use", 19, () => []), className = prop($$props, "class", 3, ""), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "use",
      "class",
      "children"
    ],
    "restProps"
  );
  let element;
  let menuSelectionGroup = getContext("SMUI:list:graphic:menu-selection-group");
  function getElement() {
    return element;
  }
  var span = root();
  let attributes;
  var node = child(span);
  snippet(node, () => $$props.children ?? noop);
  reset(span);
  bind_this(span, ($$value) => element = $$value, () => element);
  action(span, ($$node, $$action_arg) => {
    var _a;
    return (_a = useActions) == null ? void 0 : _a($$node, $$action_arg);
  }, use);
  template_effect(() => attributes = set_attributes(span, attributes, {
    class: classMap({
      [className()]: true,
      "mdc-deprecated-list-item__graphic": true,
      "mdc-menu__selection-group-icon": menuSelectionGroup
    }),
    ...restProps
  }));
  append($$anchor, span);
  return pop({
    get getElement() {
      return getElement;
    },
    ...legacy_api()
  });
}
mark_module_end(Graphic);

// node_modules/@smui/list/dist/Meta.js
var Meta_default = classAdderBuilder({
  class: "mdc-deprecated-list-item__meta",
  tag: "span"
});

// node_modules/@smui/list/dist/Label.svelte
mark_module_start();
Label[FILENAME] = "node_modules/@smui/list/dist/Label.svelte";
var root2 = add_locations(template(`<label><!></label>`), Label[FILENAME], [[3, 0]]);
function Label($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Label);
  validate_prop_bindings($$props, [], ["getElement"], Label);
  let use = prop($$props, "use", 19, () => []), className = prop($$props, "class", 3, ""), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "use",
      "class",
      "children"
    ],
    "restProps"
  );
  let element;
  let inputProps = getContext("SMUI:generic:input:props") ?? {};
  function getElement() {
    return element;
  }
  var label = root2();
  let attributes;
  var node = child(label);
  snippet(node, () => $$props.children ?? noop);
  reset(label);
  bind_this(label, ($$value) => element = $$value, () => element);
  action(label, ($$node, $$action_arg) => {
    var _a;
    return (_a = useActions) == null ? void 0 : _a($$node, $$action_arg);
  }, use);
  template_effect(() => attributes = set_attributes(label, attributes, {
    class: classMap({
      [className()]: true,
      "mdc-deprecated-list-item__text": true
    }),
    for: inputProps ? inputProps.id : void 0,
    ...restProps
  }));
  append($$anchor, label);
  return pop({
    get getElement() {
      return getElement;
    },
    ...legacy_api()
  });
}
mark_module_end(Label);

// node_modules/@smui/list/dist/Group.js
var Group_default = classAdderBuilder({
  class: "mdc-deprecated-list-group",
  tag: "div"
});

// node_modules/@smui/list/dist/Subheader.js
var Subheader_default = classAdderBuilder({
  class: "mdc-deprecated-list-group__subheader",
  tag: "h3"
});

// node_modules/@smui/list/dist/Separator.svelte
mark_module_start();
Separator[FILENAME] = "node_modules/@smui/list/dist/Separator.svelte";
function Separator($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Separator);
  validate_prop_bindings($$props, [], ["getElement"], Separator);
  let nav = getContext("SMUI:list:item:nav");
  let context = getContext("SMUI:separator:context");
  let use = prop($$props, "use", 19, () => []), className = prop($$props, "class", 3, ""), padded = prop($$props, "padded", 3, false), inset = prop($$props, "inset", 3, false), insetLeading = prop($$props, "insetLeading", 3, false), insetTrailing = prop($$props, "insetTrailing", 3, false), insetPadding = prop($$props, "insetPadding", 3, false), MyComponent = prop($$props, "component", 3, SmuiElement), tag = prop($$props, "tag", 19, () => nav || strict_equals(context, "list", false) ? "hr" : "li"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "use",
      "class",
      "padded",
      "inset",
      "insetLeading",
      "insetTrailing",
      "insetPadding",
      "component",
      "tag",
      "children"
    ],
    "restProps"
  );
  let element;
  function getElement() {
    return element.getElement();
  }
  var fragment = comment();
  var node = first_child(fragment);
  var class_1 = derived(() => classMap({
    [className()]: true,
    "mdc-deprecated-list-divider": true,
    "mdc-deprecated-list-divider--padded": padded(),
    "mdc-deprecated-list-divider--inset": inset(),
    "mdc-deprecated-list-divider--inset-leading": insetLeading(),
    "mdc-deprecated-list-divider--inset-trailing": insetTrailing(),
    "mdc-deprecated-list-divider--inset-padding": insetPadding()
  }));
  component(node, MyComponent, ($$anchor2, $$component) => {
    bind_this(
      $$component($$anchor2, spread_props(
        {
          get tag() {
            return tag();
          },
          get use() {
            return use();
          },
          get class() {
            return get(class_1);
          },
          role: "separator"
        },
        () => restProps
      )),
      ($$value) => element = $$value,
      () => element
    );
  });
  append($$anchor, fragment);
  return pop({
    get getElement() {
      return getElement;
    },
    ...legacy_api()
  });
}
mark_module_end(Separator);

// node_modules/@smui/list/dist/index.js
var dist_default2 = List;

export {
  classAdderBuilder,
  Item,
  Text_default,
  PrimaryText_default,
  SecondaryText_default,
  Graphic,
  Meta_default,
  Label,
  Group_default,
  Subheader_default,
  Separator,
  dist_default2 as dist_default
};
//# sourceMappingURL=chunk-DA3OYVDR.js.map
