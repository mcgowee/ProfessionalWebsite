import {
  MDCRippleFoundation,
  util_exports
} from "./chunk-HDMSCP4O.js";
import {
  events_exports
} from "./chunk-KV6YONZ4.js";
import {
  ponyfill_exports
} from "./chunk-KD76FVNN.js";
import {
  writable
} from "./chunk-RWE47MHO.js";
import {
  action,
  add_locations,
  bind_this,
  check_target,
  component,
  element,
  if_block,
  legacy_api,
  log_if_contains_state,
  onDestroy,
  prop,
  rest_props,
  set_attributes,
  setup_stores,
  snippet,
  spread_props,
  store_get,
  store_set,
  validate_dynamic_element_tag,
  validate_prop_bindings,
  validate_store,
  validate_void_dynamic_element,
  wrap_snippet
} from "./chunk-HZ3ZBA3K.js";
import {
  FILENAME,
  NAMESPACE_SVG,
  append,
  child,
  comment,
  derived,
  first_child,
  get,
  getContext,
  mark_module_end,
  mark_module_start,
  noop,
  ns_template,
  on,
  pop,
  proxy,
  push,
  reset,
  setContext,
  strict_equals,
  template_effect,
  user_effect
} from "./chunk-C3ERE2HV.js";

// node_modules/@smui/common/dist/internal/classMap.js
function classMap(classObj) {
  return Object.entries(classObj).filter(([name, value]) => name !== "" && value).map(([name]) => name).join(" ");
}

// node_modules/@smui/common/dist/internal/dispatch.js
function dispatch(element2, eventType, detail, eventInit = { bubbles: true }) {
  if (typeof Event === "undefined") {
    throw new Error("Event not defined.");
  }
  if (!element2) {
    throw new Error("Tried to dispatch event without element.");
  }
  const event = new CustomEvent(eventType, Object.assign(Object.assign({}, eventInit), { detail }));
  element2 === null || element2 === void 0 ? void 0 : element2.dispatchEvent(event);
  return event;
}

// node_modules/@smui/common/dist/internal/exclude.js
function exclude(obj, keys) {
  let names = Object.getOwnPropertyNames(obj);
  const newObj = {};
  for (let i = 0; i < names.length; i++) {
    const name = names[i];
    const cashIndex = name.indexOf("$");
    if (cashIndex !== -1 && keys.indexOf(name.substring(0, cashIndex + 1)) !== -1) {
      continue;
    }
    if (keys.indexOf(name) !== -1) {
      continue;
    }
    newObj[name] = obj[name];
  }
  return newObj;
}

// node_modules/@smui/common/dist/internal/prefixFilter.js
function prefixFilter(obj, prefix) {
  let names = Object.getOwnPropertyNames(obj);
  const newObj = {};
  for (let i = 0; i < names.length; i++) {
    const name = names[i];
    if (name.substring(0, prefix.length) === prefix) {
      newObj[name.substring(prefix.length)] = obj[name];
    }
  }
  return newObj;
}

// node_modules/@smui/common/dist/internal/SvelteEventManager.js
var SvelteEventManager = class {
  constructor() {
    this.elementMap = /* @__PURE__ */ new Map();
  }
  /**
   * Listen to an event on an element.
   */
  on(element2, event, handler, options) {
    if (!this.elementMap.has(element2)) {
      this.elementMap.set(element2, {});
    }
    const eventMap = this.elementMap.get(element2);
    if (eventMap == null) {
      throw new Error("Event map couldn't be created.");
    }
    if (!(event in eventMap)) {
      eventMap[event] = /* @__PURE__ */ new Map();
    }
    const handlerMap = eventMap[event];
    handlerMap.set(handler, on(element2, event, handler, options));
  }
  /**
   * Unlisten to an event on an element.
   */
  off(element2, event, handler) {
    const eventMap = this.elementMap.get(element2);
    if (eventMap == null || !(event in eventMap)) {
      return;
    }
    const handlerMap = eventMap[event];
    const unlisten = handlerMap.get(handler);
    if (unlisten != null) {
      unlisten();
      handlerMap.delete(handler);
      if (handlerMap.size === 0) {
        delete eventMap[event];
        if (Object.keys(eventMap).length === 0) {
          this.elementMap.delete(element2);
        }
      }
    }
  }
  /**
   * Unlisten to all events managed by this instance.
   */
  clear() {
    this.elementMap.forEach((eventMaps, _element) => {
      for (let [_event, eventMap] of Object.entries(eventMaps)) {
        eventMap.forEach((unlisten, _handler) => {
          unlisten();
        });
      }
    });
    this.elementMap.clear();
  }
};

// node_modules/@smui/common/dist/internal/useActions.js
function useActions(node, actions) {
  let actionReturns = [];
  if (actions) {
    for (let i = 0; i < actions.length; i++) {
      const actionEntry = actions[i];
      const action2 = Array.isArray(actionEntry) ? actionEntry[0] : actionEntry;
      if (Array.isArray(actionEntry) && actionEntry.length > 1) {
        actionReturns.push(action2(node, actionEntry[1]));
      } else {
        actionReturns.push(action2(node));
      }
    }
  }
  return {
    update(actions2) {
      if ((actions2 && actions2.length || 0) != actionReturns.length) {
        throw new Error("You must not change the length of an actions array.");
      }
      if (actions2) {
        for (let i = 0; i < actions2.length; i++) {
          const returnEntry = actionReturns[i];
          if (returnEntry && returnEntry.update) {
            const actionEntry = actions2[i];
            if (Array.isArray(actionEntry) && actionEntry.length > 1) {
              returnEntry.update(actionEntry[1]);
            } else {
              returnEntry.update();
            }
          }
        }
      }
    },
    destroy() {
      for (let i = 0; i < actionReturns.length; i++) {
        const returnEntry = actionReturns[i];
        if (returnEntry && returnEntry.destroy) {
          returnEntry.destroy();
        }
      }
    }
  };
}

// node_modules/@smui/common/dist/CommonIcon.svelte
mark_module_start();
CommonIcon[FILENAME] = "node_modules/@smui/common/dist/CommonIcon.svelte";
function CommonIcon($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, CommonIcon);
  validate_prop_bindings($$props, [], ["getElement"], CommonIcon);
  let use = prop($$props, "use", 19, () => []), className = prop($$props, "class", 3, ""), on2 = prop($$props, "on", 3, false), MyComponent = prop($$props, "component", 3, SmuiElement), tag = prop($$props, "tag", 3, "i"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "use",
      "class",
      "on",
      "component",
      "tag",
      "children"
    ],
    "restProps"
  );
  let element2;
  const svg = derived(() => strict_equals(tag(), "svg") || strict_equals(MyComponent(), Svg));
  const context = getContext("SMUI:icon:context");
  function getElement() {
    return element2.getElement();
  }
  var fragment = comment();
  var node = first_child(fragment);
  var class_1 = derived(() => classMap({
    [className()]: true,
    "mdc-button__icon": strict_equals(context, "button"),
    "mdc-fab__icon": strict_equals(context, "fab"),
    "mdc-icon-button__icon": strict_equals(context, "icon-button"),
    "mdc-icon-button__icon--on": strict_equals(context, "icon-button") && on2(),
    "mdc-tab__icon": strict_equals(context, "tab"),
    "mdc-banner__icon": strict_equals(context, "banner"),
    "mdc-segmented-button__icon": strict_equals(context, "segmented-button")
  }));
  component(node, MyComponent, ($$anchor2, $$component) => {
    bind_this(
      $$component($$anchor2, spread_props(
        {
          get tag() {
            return tag();
          },
          get use() {
            return use();
          },
          get class() {
            return get(class_1);
          },
          "aria-hidden": "true"
        },
        () => get(svg) ? { focusable: "false", tabindex: "-1" } : {},
        () => restProps,
        {
          children: wrap_snippet(CommonIcon, ($$anchor3, $$slotProps) => {
            var fragment_1 = comment();
            var node_1 = first_child(fragment_1);
            snippet(node_1, () => $$props.children ?? noop);
            append($$anchor3, fragment_1);
          }),
          $$slots: { default: true }
        }
      )),
      ($$value) => element2 = $$value,
      () => element2
    );
  });
  append($$anchor, fragment);
  return pop({
    get getElement() {
      return getElement;
    },
    ...legacy_api()
  });
}
mark_module_end(CommonIcon);

// node_modules/@smui/common/dist/SmuiElement.svelte
mark_module_start();
SmuiElement[FILENAME] = "node_modules/@smui/common/dist/SmuiElement.svelte";
var root_1 = add_locations(ns_template(`<svg><!></svg>`), SmuiElement[FILENAME], [[4, 2]]);
function SmuiElement($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, SmuiElement);
  validate_prop_bindings($$props, [], ["getElement"], SmuiElement);
  let use = prop($$props, "use", 19, () => []), tag = prop($$props, "tag", 3, "div"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "use",
      "tag",
      "children"
    ],
    "restProps"
  );
  const selfClosing = derived(() => [
    "area",
    "base",
    "br",
    "col",
    "embed",
    "hr",
    "img",
    "input",
    "link",
    "meta",
    "param",
    "source",
    "track",
    "wbr"
  ].indexOf(tag()) > -1);
  let element2;
  function getElement() {
    return element2;
  }
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var svg = root_1();
      let attributes;
      var node_1 = child(svg);
      snippet(node_1, () => $$props.children ?? noop);
      reset(svg);
      bind_this(svg, ($$value) => element2 = $$value, () => element2);
      action(svg, ($$node, $$action_arg) => {
        var _a;
        return (_a = useActions) == null ? void 0 : _a($$node, $$action_arg);
      }, use);
      template_effect(() => attributes = set_attributes(svg, attributes, { ...restProps }, void 0, true));
      append($$anchor2, svg);
    };
    var alternate_1 = ($$anchor2) => {
      var fragment_1 = comment();
      var node_2 = first_child(fragment_1);
      {
        var consequent_1 = ($$anchor3) => {
          var fragment_2 = comment();
          var node_3 = first_child(fragment_2);
          validate_dynamic_element_tag(tag);
          element(
            node_3,
            tag,
            false,
            ($$element, $$anchor4) => {
              bind_this($$element, ($$value) => element2 = $$value, () => element2);
              action($$element, ($$node, $$action_arg) => {
                var _a;
                return (_a = useActions) == null ? void 0 : _a($$node, $$action_arg);
              }, use);
              let attributes_1;
              template_effect(() => attributes_1 = set_attributes($$element, attributes_1, { ...restProps }, void 0, $$element.namespaceURI === NAMESPACE_SVG, $$element.nodeName.includes("-")));
            },
            void 0,
            [8, 2]
          );
          append($$anchor3, fragment_2);
        };
        var alternate = ($$anchor3) => {
          var fragment_3 = comment();
          var node_4 = first_child(fragment_3);
          validate_void_dynamic_element(tag);
          validate_dynamic_element_tag(tag);
          element(
            node_4,
            tag,
            false,
            ($$element_1, $$anchor4) => {
              bind_this($$element_1, ($$value) => element2 = $$value, () => element2);
              action($$element_1, ($$node, $$action_arg) => {
                var _a;
                return (_a = useActions) == null ? void 0 : _a($$node, $$action_arg);
              }, use);
              let attributes_2;
              template_effect(() => attributes_2 = set_attributes($$element_1, attributes_2, { ...restProps }, void 0, $$element_1.namespaceURI === NAMESPACE_SVG, $$element_1.nodeName.includes("-")));
              var fragment_4 = comment();
              var node_5 = first_child(fragment_4);
              snippet(node_5, () => $$props.children ?? noop);
              append($$anchor4, fragment_4);
            },
            void 0,
            [15, 2]
          );
          append($$anchor3, fragment_3);
        };
        if_block(
          node_2,
          ($$render) => {
            if (get(selfClosing)) $$render(consequent_1);
            else $$render(alternate, false);
          },
          true
        );
      }
      append($$anchor2, fragment_1);
    };
    if_block(node, ($$render) => {
      if (strict_equals(tag(), "svg")) $$render(consequent);
      else $$render(alternate_1, false);
    });
  }
  append($$anchor, fragment);
  return pop({
    get getElement() {
      return getElement;
    },
    ...legacy_api()
  });
}
mark_module_end(SmuiElement);

// node_modules/@smui/common/dist/Svg.svelte
mark_module_start();
Svg[FILENAME] = "node_modules/@smui/common/dist/Svg.svelte";
var root = add_locations(ns_template(`<svg><!></svg>`), Svg[FILENAME], [[3, 0]]);
function Svg($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Svg);
  validate_prop_bindings($$props, [], ["getElement"], Svg);
  if (console && console.warn) {
    console.warn(...log_if_contains_state("warn", 'The @smui/common Svg component is deprecated. You can use `tag="svg"` now.'));
  }
  let use = prop($$props, "use", 19, () => []), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "use",
      "children"
    ],
    "restProps"
  );
  let element2;
  function getElement() {
    return element2;
  }
  var svg = root();
  let attributes;
  var node = child(svg);
  snippet(node, () => $$props.children ?? noop);
  reset(svg);
  bind_this(svg, ($$value) => element2 = $$value, () => element2);
  action(svg, ($$node, $$action_arg) => {
    var _a;
    return (_a = useActions) == null ? void 0 : _a($$node, $$action_arg);
  }, use);
  template_effect(() => attributes = set_attributes(svg, attributes, { ...restProps }, void 0, true));
  append($$anchor, svg);
  return pop({
    get getElement() {
      return getElement;
    },
    ...legacy_api()
  });
}
mark_module_end(Svg);

// node_modules/@smui/common/dist/ContextFragment.svelte
mark_module_start();
ContextFragment[FILENAME] = "node_modules/@smui/common/dist/ContextFragment.svelte";
function ContextFragment($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, ContextFragment);
  const $$stores = setup_stores();
  const $storeValue = () => (validate_store(storeValue, "storeValue"), store_get(storeValue, "$storeValue", $$stores));
  validate_prop_bindings($$props, [], [], ContextFragment);
  const storeValue = writable($$props.value);
  setContext($$props.key, storeValue);
  user_effect(() => {
    store_set(storeValue, proxy($$props.value, null, $storeValue));
  });
  onDestroy(() => {
    storeValue.set(void 0);
  });
  var fragment = comment();
  var node = first_child(fragment);
  snippet(node, () => $$props.children ?? noop);
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
mark_module_end(ContextFragment);

// node_modules/@smui/common/dist/CommonLabel.svelte
mark_module_start();
CommonLabel[FILENAME] = "node_modules/@smui/common/dist/CommonLabel.svelte";
function CommonLabel($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, CommonLabel);
  validate_prop_bindings($$props, [], ["getElement"], CommonLabel);
  let use = prop($$props, "use", 19, () => []), className = prop($$props, "class", 3, ""), MyComponent = prop($$props, "component", 3, SmuiElement), tag = prop($$props, "tag", 3, "span"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "use",
      "class",
      "component",
      "tag",
      "children"
    ],
    "restProps"
  );
  let element2;
  const context = getContext("SMUI:label:context");
  const tabindex = getContext("SMUI:label:tabindex");
  function getElement() {
    return element2.getElement();
  }
  var fragment = comment();
  var node = first_child(fragment);
  var class_1 = derived(() => classMap({
    [className()]: true,
    "mdc-button__label": strict_equals(context, "button"),
    "mdc-fab__label": strict_equals(context, "fab"),
    "mdc-tab__text-label": strict_equals(context, "tab"),
    "mdc-image-list__label": strict_equals(context, "image-list"),
    "mdc-snackbar__label": strict_equals(context, "snackbar"),
    "mdc-banner__text": strict_equals(context, "banner"),
    "mdc-segmented-button__label": strict_equals(context, "segmented-button"),
    "mdc-data-table__pagination-rows-per-page-label": strict_equals(context, "data-table:pagination"),
    "mdc-data-table__header-cell-label": strict_equals(context, "data-table:sortable-header-cell")
  }));
  component(node, MyComponent, ($$anchor2, $$component) => {
    bind_this(
      $$component($$anchor2, spread_props(
        {
          get tag() {
            return tag();
          },
          get use() {
            return use();
          },
          get class() {
            return get(class_1);
          }
        },
        strict_equals(context, "snackbar") ? { "aria-atomic": "false" } : {},
        { tabindex },
        () => restProps,
        {
          children: wrap_snippet(CommonLabel, ($$anchor3, $$slotProps) => {
            var fragment_1 = comment();
            var node_1 = first_child(fragment_1);
            snippet(node_1, () => $$props.children ?? noop);
            append($$anchor3, fragment_1);
          }),
          $$slots: { default: true }
        }
      )),
      ($$value) => element2 = $$value,
      () => element2
    );
  });
  append($$anchor, fragment);
  return pop({
    get getElement() {
      return getElement;
    },
    ...legacy_api()
  });
}
mark_module_end(CommonLabel);

// node_modules/@smui/ripple/dist/Ripple.js
var { applyPassive } = events_exports;
var { matches } = ponyfill_exports;
function Ripple(node, { ripple = true, surface = false, unbounded = false, disabled = false, color, active, rippleElement, eventTarget, activeTarget, addClass = (className) => node.classList.add(className), removeClass = (className) => node.classList.remove(className), addStyle = (name, value) => node.style.setProperty(name, value), initPromise = Promise.resolve() } = {}) {
  let instance;
  let eventManager = new SvelteEventManager();
  let addLayoutListener = getContext("SMUI:addLayoutListener");
  let removeLayoutListener;
  let oldActive = active;
  let oldEventTarget = eventTarget;
  let oldActiveTarget = activeTarget;
  function handleProps() {
    if (surface) {
      addClass("mdc-ripple-surface");
      if (color === "primary") {
        addClass("smui-ripple-surface--primary");
        removeClass("smui-ripple-surface--secondary");
      } else if (color === "secondary") {
        removeClass("smui-ripple-surface--primary");
        addClass("smui-ripple-surface--secondary");
      } else {
        removeClass("smui-ripple-surface--primary");
        removeClass("smui-ripple-surface--secondary");
      }
    } else {
      removeClass("mdc-ripple-surface");
      removeClass("smui-ripple-surface--primary");
      removeClass("smui-ripple-surface--secondary");
    }
    if (instance && oldActive !== active) {
      oldActive = active;
      if (active) {
        instance.activate();
      } else if (active === false) {
        instance.deactivate();
      }
    }
    if (ripple && !instance) {
      instance = new MDCRippleFoundation({
        addClass,
        browserSupportsCssVars: () => util_exports.supportsCssVariables(window),
        computeBoundingRect: () => (rippleElement || node).getBoundingClientRect(),
        containsEventTarget: (target) => node.contains(target),
        deregisterDocumentInteractionHandler: (evtType, handler) => eventManager.off(document.documentElement, evtType, handler),
        deregisterInteractionHandler: (evtType, handler) => eventManager.off(eventTarget || node, evtType, handler),
        deregisterResizeHandler: (handler) => window.removeEventListener("resize", handler),
        getWindowPageOffset: () => {
          var _a, _b;
          return {
            x: (_a = window.pageXOffset) !== null && _a !== void 0 ? _a : window.scrollX,
            y: (_b = window.pageYOffset) !== null && _b !== void 0 ? _b : window.scrollY
          };
        },
        isSurfaceActive: () => active == null ? matches(activeTarget || node, ":active") : active,
        isSurfaceDisabled: () => !!disabled,
        isUnbounded: () => !!unbounded,
        registerDocumentInteractionHandler: (evtType, handler) => {
          const opts = applyPassive();
          eventManager.on(document.documentElement, evtType, handler, typeof opts === "boolean" ? { capture: opts } : opts);
        },
        registerInteractionHandler: (evtType, handler) => {
          const opts = applyPassive();
          eventManager.on(eventTarget || node, evtType, handler, typeof opts === "boolean" ? { capture: opts } : opts);
        },
        registerResizeHandler: (handler) => eventManager.on(window, "resize", handler),
        removeClass,
        updateCssVariable: addStyle
      });
      initPromise.then(() => {
        if (instance) {
          instance.init();
          instance.setUnbounded(unbounded);
        }
      });
    } else if (instance && !ripple) {
      initPromise.then(() => {
        if (instance) {
          instance.destroy();
          instance = void 0;
          eventManager.clear();
        }
      });
    }
    if (instance && (oldEventTarget !== eventTarget || oldActiveTarget !== activeTarget)) {
      oldEventTarget = eventTarget;
      oldActiveTarget = activeTarget;
      instance.destroy();
      requestAnimationFrame(() => {
        if (instance) {
          instance.init();
          instance.setUnbounded(unbounded);
        }
      });
    }
    if (!ripple && unbounded) {
      addClass("mdc-ripple-upgraded--unbounded");
    }
  }
  handleProps();
  if (addLayoutListener) {
    removeLayoutListener = addLayoutListener(layout);
  }
  function layout() {
    if (instance) {
      instance.layout();
    }
  }
  return {
    update(props) {
      ({
        ripple,
        surface,
        unbounded,
        disabled,
        color,
        active,
        rippleElement,
        eventTarget,
        activeTarget,
        addClass,
        removeClass,
        addStyle,
        initPromise
      } = Object.assign({ ripple: true, surface: false, unbounded: false, disabled: false, color: void 0, active: void 0, rippleElement: void 0, eventTarget: void 0, activeTarget: void 0, addClass: (className) => node.classList.add(className), removeClass: (className) => node.classList.remove(className), addStyle: (name, value) => node.style.setProperty(name, value), initPromise: Promise.resolve() }, props));
      handleProps();
    },
    destroy() {
      if (instance) {
        instance.destroy();
        instance = void 0;
        eventManager.clear();
        removeClass("mdc-ripple-surface");
        removeClass("smui-ripple-surface--primary");
        removeClass("smui-ripple-surface--secondary");
      }
      if (removeLayoutListener) {
        removeLayoutListener();
      }
    }
  };
}

// node_modules/@smui/ripple/dist/index.js
var dist_default = Ripple;

export {
  classMap,
  dispatch,
  exclude,
  prefixFilter,
  useActions,
  CommonLabel,
  CommonIcon,
  SmuiElement,
  dist_default
};
//# sourceMappingURL=chunk-TP3TIDAL.js.map
